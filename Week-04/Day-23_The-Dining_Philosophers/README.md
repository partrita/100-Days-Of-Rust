## 식사하는 철학자들

다섯 명의 말없는 철학자가 스파게티 그릇이 놓인 원형 테이블에 앉아 있습니다. 포크는 인접한 철학자 쌍 사이에 놓여 있습니다.

각 철학자는 번갈아 생각하고 식사해야 합니다. 그러나 철학자는 왼쪽과 오른쪽 포크를 모두 가지고 있을 때만 스파게티를 먹을 수 있습니다. 각 포크는 한 명의 철학자만 잡을 수 있으므로 철학자는 다른 철학자가 사용하지 않는 경우에만 포크를 사용할 수 있습니다. 개별 철학자가 식사를 마치면 다른 사람이 사용할 수 있도록 두 포크를 모두 내려놓아야 합니다. 철학자는 사용 가능해지면 오른쪽 또는 왼쪽 포크를 가져갈 수 있지만 두 포크를 모두 얻기 전에는 식사를 시작할 수 없습니다.

식사는 남은 스파게티 양이나 위장 공간에 의해 제한되지 않습니다. 무한한 공급과 무한한 수요가 가정됩니다.

어떤 철학자도 굶주리지 않도록 행동 규율(동시성 알고리즘)을 설계하십시오. 즉, 다른 철학자가 언제 먹거나 생각하고 싶어하는지 알 수 없다고 가정할 때 각 철학자는 영원히 식사와 생각 사이를 번갈아 가며 계속할 수 있습니다.

<p align="left">
  <img src="../../assets/dining_philosophers_problem.png" width=400 height=400 alt="식사하는 철학자들">
</p>

철학자 ID는 **시계 방향**으로 **0**에서 **4**까지 번호가 매겨집니다. 다음 함수를 구현하십시오: void wantsToEat(philosopher, pickLeftFork, pickRightFork, eat, putLeftFork, putRightFork)

- `philosopher`는 식사를 원하는 철학자의 ID입니다.
- `pickLeftFork`와 `pickRightFork`는 해당 철학자의 해당 포크를 집기 위해 호출할 수 있는 함수입니다.
- `eat`은 철학자가 두 포크를 모두 집으면 식사하도록 호출할 수 있는 함수입니다.
- `putLeftFork`와 `putRightFork`는 해당 철학자의 해당 포크를 내려놓기 위해 호출할 수 있는 함수입니다.
- 철학자들은 식사를 요청하지 않는 한(해당 번호로 함수가 호출되지 않는 한) 생각하고 있는 것으로 간주됩니다.

각각 철학자를 나타내는 다섯 개의 스레드가 동시에 클래스의 한 개체를 사용하여 프로세스를 시뮬레이션합니다. 마지막 호출이 끝나기 전이라도 동일한 철학자에 대해 함수가 두 번 이상 호출될 수 있습니다.

### 예시

```text
입력: n = 1
출력: [[4,2,1],[4,1,1],[0,1,1],[2,2,1],[2,1,1],[2,0,3],[2,1,2],[2,2,2],[4,0,3],[4,1,2],[0,2,1],[4,2,2],[3,2,1],[3,1,1],[0,0,3],[0,1,2],[0,2,2],[1,2,1],[1,1,1],[3,0,3],[3,1,2],[3,2,2],[1,0,3],[1,1,2],[1,2,2]]

설명:
n은 각 철학자가 함수를 호출하는 횟수입니다.
출력 배열은 포크와 eat 함수를 제어하는 함수에 대한 호출을 설명하며 형식은 다음과 같습니다:
output[i] = [a, b, c] (세 개의 정수)

- a는 철학자의 ID입니다.
- b는 포크를 지정합니다: {1: 왼쪽, 2: 오른쪽}.
- c는 작업을 지정합니다: {1: 집기, 2: 놓기, 3: 먹기}.
```

### 제약 조건

- `1 <= n <= 60`
